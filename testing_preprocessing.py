# -*- coding: utf-8 -*-
"""Testing_Preprocessing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RehYcOdEC4yqI7g57E6qirOr-OPQRGgF

# Data Preprocessing of CvTLeukemia model
"""

import numpy as np
import cv2
from sklearn.decomposition import NMF
from scipy.linalg import svd

def rgb_to_od(I, Ib):
    """Convert RGB image to Optical Density (OD) space."""
    I = I.astype(np.float32)
    Ib = Ib.astype(np.float32)
    return -np.log((I + 1) / (Ib + 1))  # add 1 to avoid division by zero

def od_to_rgb(OD, Ib):
    """Convert OD image back to RGB."""
    I = Ib * np.exp(-OD)
    I = np.clip(I, 0, 255).astype(np.uint8)
    return I

def estimate_background(img, percentile=99.9, kernel_size=71):
    """Estimate background intensity using a large averaging filter."""
    img_gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
    img_med = cv2.medianBlur(img_gray, 3)
    img_smooth = cv2.blur(img_med, (kernel_size, kernel_size))
    T = np.percentile(img_smooth, percentile)
    mask = img_smooth >= T
    bg_means = [np.mean(img[:, :, i][mask]) for i in range(3)]
    return np.array(bg_means)

def stain_basis_svd(OD):
    """Compute stain basis vectors using SVD."""
    OD_flat = OD.reshape(-1, 3).T
    U, S, Vt = svd(OD_flat, full_matrices=False)
    return U

def align_basis(U_ref, U_query):
    """Align the basis vectors of query image to reference image."""
    # Find permutation minimizing Frobenius norm difference
    from itertools import permutations
    best_perm = None
    min_dist = np.inf
    for perm in permutations(range(3)):
        dist = np.linalg.norm(U_ref - U_query[:, perm], ord='fro')
        if dist < min_dist:
            min_dist = dist
            best_perm = perm
    aligned_query = U_query[:, best_perm]
    return aligned_query

def stain_quantity_correction(A_query, A_ref, percentile=99.9):
    """Match stain quantity percentiles between query and reference."""
    for i in range(A_query.shape[0]):
        p_query = np.percentile(A_query[i, :], percentile)
        p_ref = np.percentile(A_ref[i, :], percentile)
        if p_query > 0:
            A_query[i, :] *= p_ref / p_query
    return A_query

def gcti_sn_normalization(I_query, I_ref):
    """Full GCTI-SN pipeline."""
    # Step 1: Illumination Correction
    Ib_ref = estimate_background(I_ref)
    Ib_query = estimate_background(I_query)

    OD_ref = rgb_to_od(I_ref, Ib_ref)
    OD_query = rgb_to_od(I_query, Ib_query)

    # Step 2: Stain Color Vector Correction
    U_ref = stain_basis_svd(OD_ref)
    U_query = stain_basis_svd(OD_query)
    U_query_aligned = align_basis(U_ref, U_query)

    # Project OD images to stain space
    A_ref = np.dot(U_ref.T, OD_ref.reshape(-1, 3).T)
    A_query = np.dot(U_query_aligned.T, OD_query.reshape(-1, 3).T)

    # Step 3: Stain Quantity Correction
    A_query_corrected = stain_quantity_correction(A_query.copy(), A_ref)

    # Reconstruct corrected OD
    OD_query_corrected = np.dot(U_ref, A_query_corrected).T.reshape(I_query.shape)

    # Convert back to RGB
    I_norm = od_to_rgb(OD_query_corrected, Ib_ref)
    return I_norm

# Example usage:
if __name__ == "__main__":
    # Load reference and query images
    I_ref = cv2.cvtColor(cv2.imread("/content/HEM Not Affected.bmp"), cv2.COLOR_BGR2RGB)
    I_query = cv2.cvtColor(cv2.imread("/content/Im003_23.jpg"), cv2.COLOR_BGR2RGB)

    I_normalized = gcti_sn_normalization(I_query, I_ref)

    # Save or display the normalized image
    cv2.imwrite("normalized_query.png", cv2.cvtColor(I_normalized, cv2.COLOR_RGB2BGR))
    print("✅ Stain normalization complete. Saved as 'normalized_query.png'.")

"""# Custom Build Pre-processing mechanism based on the training dataset"""

import cv2
import numpy as np
from matplotlib import pyplot as plt

def preprocess_nucleus(image_path, output_path='output_image.png'):
    # Step 1: Load image
    img = cv2.imread(image_path)
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

    # Step 2: Convert to HSV for better color segmentation
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    # Step 3: Define HSV range for violet/purple nucleus
    lower_purple = np.array([120, 70, 50])
    upper_purple = np.array([160, 255, 255])
    mask = cv2.inRange(hsv, lower_purple, upper_purple)

    # Step 4: Morphological operations to clean up mask
    kernel = np.ones((5, 5), np.uint8)
    mask_clean = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
    mask_clean = cv2.morphologyEx(mask_clean, cv2.MORPH_OPEN, kernel)

    # Step 5: Find contours (extract nucleus)
    contours, _ = cv2.findContours(mask_clean, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if contours:
        # Get the largest contour assuming it is the nucleus
        largest_contour = max(contours, key=cv2.contourArea)
        nucleus_mask = np.zeros_like(mask_clean)
        cv2.drawContours(nucleus_mask, [largest_contour], -1, 255, thickness=cv2.FILLED)
    else:
        print("No nucleus detected.")
        return

    # Step 6: Brighten the nucleus region
    brightened_img = img_rgb.copy()
    # Increase brightness by scaling the pixel values in the nucleus region
    brightened_img[nucleus_mask == 255] = cv2.add(brightened_img[nucleus_mask == 255], -10)
    brightened_img = np.clip(brightened_img, 0, 255)

    # Step 7: Replace background with black
    result = np.zeros_like(brightened_img)
    result[nucleus_mask == 255] = brightened_img[nucleus_mask == 255]

    # Step 8: Save and show
    plt.figure(figsize=(10, 5))
    plt.subplot(1, 3, 1)
    plt.title("Original")
    plt.imshow(img_rgb)
    plt.axis("off")

    #plt.subplot(1, 3, 2)
    #plt.title("Nucleus Mask")
    #plt.imshow(nucleus_mask, cmap='gray')
    #plt.axis("off")

    plt.subplot(1, 3, 3)
    plt.title("Final Output")
    plt.imshow(result)
    plt.axis("off")
    plt.tight_layout()
    plt.show()

    # Save output
    result_bgr = cv2.cvtColor(result, cv2.COLOR_RGB2BGR)
    cv2.imwrite(output_path, result_bgr)
    print(f"✅ Processed image saved at: {output_path}")

# Example usage
preprocess_nucleus('/content/Extracted_WBC_Nuc.jpg', output_path='output_image.png')